#!/bin/bash

# Author Erik Lilja, github@lilja
log_path="$HOME/.config/timelogs"

# Increased log level = more debugy
log_level=0

# Version
VERSION="0.3.0"

function logger_debug {
  [ $log_level -ge 1 ] && echo "$(date +%Y-%m-%d\ %H:%M:%S) DEBUG $1"
}

function usage {
    echo "Timelog version: $VERSION"
    echo "Timelog is a script written for keeping track of time for projects."
    echo "It will log time inputed via this CLI to store it to the disk in \$HOME/.config/timelog/project_id.log."
    echo ""
    echo "Usage: $(basename $0)"
    echo " * log (project_id) (start time, end time, break time)"
    echo " * list project"
    echo " * show logs (project_id) (week) | (--raw)"
    echo " * delete project"
    echo " * --help"
		echo " * --version"
    echo ""
    echo "For debugging, run with -v"
    echo "To see examples, run $(basename $0) --examples"
    echo "All arguments in parenthesis will be prompted to the user if not supplied"
    echo "All arguments in brackets are optional which will have a default value if not supplied."
    [ $1 -eq 1 ] && exit 1 || exit 0
}

function examples {
  bin=$(basename $0)
  echo "$bin create project"
  echo "... follow the prompt text"
  echo "$bin log project test 08:30 14:00 30"
  echo "Save this? y/n y"
  echo "$bin list projects"
  echo "1. Test[ts]"
  exit 0
}

function list_projects {
  files=$(ls $log_path/def/ 2>/dev/null)
  it=1
  for file_name in $files; do
    file=$(cat $log_path/def/$file_name)
    name=$(echo "$file" | grep -o 'project_name\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1')
    id=$(echo "$file" | grep -o 'project_id\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1')
    printf "${it}: $name [$id]\n"
    it=$((it+1))
  done
}

function get_project_meta_info {
  file=$(cat "$log_path/def/$1")
  target_hours=$(echo "$file" | grep -o 'target_hours\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1')
  money=$(echo "$file" | grep -o 'money_per_hour\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1')
  currency=$(echo "$file" | grep -o 'currency\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1')
  logger_debug "Target_hours: $target_hours"
  logger_debug "Money: $money"
  logger_debug "Currency: $currency"
}

function week_stats {
  # $1 = content of a project file(string)
  # $2 = the week to look at
  # $3 = the year to look at
  # RELIES ON THAT global variable $target_hours has been set!
  file_contents=$1
  week=$2
  year=$3
  logger_debug "project name: '$proj_name'"
  logger_debug "Week: '$week'"
  logger_debug "Year: '$year'"
  records=$(echo "$file_contents" | grep "$year-$week-[1-7]*\/")
  day=$(echo "$records" | grep -o "\/$year-[0-9]\+-[0-9]\+" | sed 's#^\/##')
  if [ -z $target_hours ]; then { echo "Target hours not specified." ; exit 1 ; } fi

  dec_time=0
  dec_time_for_day=0
  # Calculate how much time has been spent on a week
  if [ ! -z "$records" ]; then
    echo "Days worked for week $week"
    while read -r record; do
      day=$(echo "$record" | grep -o "\/$year-[0-9]\+-[0-9]\+" | sed 's#^\/##')
      dec_time_for_day=$(echo "$record" | grep -o '\[[0-9]\+\.*[0-9]*\]' | grep -o '[0-9]*\.*[0-9]*')
      mil_time_for_day=$(echo "$record" | grep -o '\{[0-9]*:[0-9]*\}' | grep -o '[0-9]*:[0-9]*')
      day=$(date -d "$day" +%A | sed  's/^\(.\)/\U\1/') # Sed regex converts first char to uppercase. monday=>Monday
      dec_time=$(awk "BEGIN {print ($dec_time+$dec_time_for_day)}") # Awk this because it can contain decimals.
      echo "$day: ${dec_time_for_day}h / $mil_time_for_day"
    done <<< "$records"

    weekly_info=$(weekly_stats_days "$file_contents" "$week" "$year")
    amount_of_days_worked=$(echo $weekly_info | wc -w)
    echo "------"
    echo "You have worked for $dec_time hours at the following days: $weekly_info"
    remaining=$(awk "BEGIN {print ($target_hours-$dec_time)}")
    days_in_a_work_week=5

    # Check if there is an remaining number of hours compoared to the total_hours. If so, give an estimate.
    if [ $(echo "$remaining" | awk '($1 < 0){ exit 1 }' ; echo $?) ]; then
      days=$(($days_in_a_work_week-$amount_of_days_worked))
      logger_debug "Worked for $amount_of_days_worked days. Amount of remaining days(Assuming $days_in_a_work_week-day work week):$days"

      # If about to do an estimate calculation, make sure that the worked days does not exceed days in a work week.
      # Because it might cause an division by zero error
      if [ $amount_of_days_worked -ge $days_in_a_work_week ]; then
        days_in_a_work_week=7
        days=$(($days_in_a_work_week-$amount_of_days_worked))
        logger_debug "The days in a work week is exceeded by the number of days that has been worked."
        logger_debug "Setting the days in a work week to $days_in_a_work_week"
      fi

      estimate=$(awk "BEGIN {print ($remaining/$days)}")
      if [ $(echo "$estimate" | awk '($1 < 0){ exit 1 } ' ; echo $?) ]; then
        echo "You have $remaining hours more to work, out of the total hours of $target_hours"
        echo "This yields an estimate of $estimate hours for $days more days."
      fi
    else
      echo "All hours caught up!"
      overtime=$(awk "BEGIN { print($dec_time-$target_hours) }")
      echo "You have overtime of $overtime hours"
    fi
    if [ ! -z "$money" ]; then
      echo "You have earned $(awk "BEGIN {print ($dec_time*$money)}") $currency pre-tax!"
    fi

  else
    echo "Nothing worked on week $week year $year for project $proj_name"
  fi
}

function weekly_stats_days {
  # $1 = Contents of the log file
  # $2 = what week to search for
  # $3 = What year to search for
  k=(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)
  file_contents=$1
  week=$2
  year=$3
  days=$(echo "$file_contents" | grep -o "$year-$week-[1-7]*\/" | grep -o '\-[1-7]\/' | grep -o '[1-7]' | sort)
  day_str=""
  for day in $days; do
    day_str="$day_str, ${k[((day-1))]}"
  done
  day_str=$(echo "$day_str" | sed 's/^,\ //')
  echo "$day_str"
}

function get_all_projects {
  all_projects=$(list_projects)
}

function parse_timestamp {
  hour="" ; minute=""

  if [[ ${#1} -eq 1 ]]; then
    # 0-9
    hour=$(echo $1 | grep -o '[0-9]\{1\}'); hour="0$hour"; minute="00"
  elif [[ ${#1} -eq 2 ]]; then
    # 10-23
    hour=$(echo $1 | grep -o '\(\(1[0-9]\)\|2\([0-3]\)\)'); minute="00"
  elif [[ ${#1} -eq 5 ]]; then
    # 08:00
    hour=$(echo $1 | grep -o '^[0-9]\{2\}');
    minute=$(echo $1 | grep -o '\:\{1\}[0-9]\{2\}$' | sed 's#\:##')
  elif [[ ${#1} -eq 4 ]]; then
    # 0800 or 8:00
    if [[ $1 = *":"* ]]; then
      hour=$(echo $1 | grep -o '^[0-9]\{1\}'); hour="0$hour";
      minute=$(echo $1 | grep -o '\:[0-9]\{2\}$' | sed 's#\:##')
    else
      hour=$(echo $1 | grep -o '^[0-9]\{2\}'); minute=$(echo $1 | grep -o '[0-9]\{2\}$')
    fi
  elif [[ ${#1} -eq 3 ]]; then
    # 800
    hour=$(echo $1 | grep -o '^[1-9]\{1\}'); hour="0$hour";
    minute=$(echo $1 | grep -o '[0-9]\{2\}$')
  else
    # ?????
    hour=""; mintue=""
  fi
  echo "$hour $minute"
}

function test_timestamp {
  k=$(echo "$1" | grep -o '[0-9][0-9]\ [0-9][0-9]')
  logger_debug "test_timestamp: '$1' => '$k'"
  [ "$k" == "$1" ] && exit 0 || exit 1
}

function test_break {
  k=$(echo $1 | grep -o '[0-9]*')
  logger_debug "test_break: '$1' => '$k'"
  [ $k == $1 ] && exit 0 || exit 1
}

function does_project_exist {
  if [ -f "$log_path/def/$1" ]; then exit 0; else exit 1; fi
}

function delete_project {
  if [ ! -z "$all_projects" ]; then
    echo "The projects"
    echo -e "$all_projects"

    echo "Which project do you want deleted?"
    read proj

    echo "Are you sure you want to delete it? (y/n)"
    read ans
    if [ "$ans" = "y" ]; then
      logger_debug "Sending $proj as param info to project info"
      proj=$(get_project_from_all_projects $proj)
      logger_debug "Matched '$proj'"
      [ -f "$log_path/def/$proj" ] && {
        rm "$log_path/$proj.logs" ;
        rm "$log_path/def/$proj" ;
        logger_debug "Deleting logs '$proj_name.logs'" ;
        logger_debug "Deleting definition 'def/$proj_name'" ;
        all_projects=$(list_projects) ;
      } || {
        echo "No such project file: '$log_path/def/$proj'" ;
      }
    fi
  else
    echo "No projects, can't delete nothing that doesn't exist!"
  fi
}

function get_project_from_all_projects {
  echo "$all_projects" | grep "^$1"  | grep -o ':\ .*\[' | sed 's#^:\ *\(.*\)\[$#\1#' | sed 's/*//;s/ *$//'
}

function get_project_from_id {
  echo "$all_projects" | grep "\[$1\]" | grep -o ':\ .*\[' | sed 's#^:\ *\(.*\)\[$#\1#' | sed 's/*//;s/ *$//'
}

function describe_project {
  echo "Creating a new project"
  echo "What would you like to call it?"
  read project_name

  echo "What is an ID that you would call it?"
  echo "(This is used to specify which project you would like to submit time to)"
  read project_id

  echo "What is the target hours per week?"
  read target_hours

  echo "What does the project pay(per hour)? Enter s to skip"
  read money_per_hour

  if [ "$money_per_hour" != "s" ]; then
    echo "What is the currency paid?"
    read currency
  fi

  if [ ! -f "$log_path/def/$project_name" ]; then
    logger_debug "Initalizing project $project_name"
    touch $log_path/def/$project_name
    touch $log_path/$project_name.logs
    echo "project_name=$project_name" > $log_path/def/$project_name
    echo "project_id=$project_id" >> $log_path/def/$project_name
    echo "target_hours=$target_hours" >> $log_path/def/$project_name
    if [ "$money_per_hour" != "s" ]; then
      echo "money_per_hour=$money_per_hour" >> $log_path/def/$project_name
      echo "currency=$currency" >> $log_path/def/$project_name
    fi
  else
    echo "Could not create project, it already exists!"
    logger_debug "Could not create $project_name since $log_path/def/$project_name does exists"
  fi
}

function init_program {
  mkdir -p $log_path; logger_debug "Created $log_path";
  mkdir $log_path/def/; logger_debug "Created $log_path/def";
  touch $log_path/config
  echo "default_project=" > $log_path/config
  logger_debug "Initalizing the program. Creating folder and config."
}

function get_default_project {
  cat $log_path/config | grep -o 'default_project\ *\=\ *.*' | cut -d '=' -f 2- | awk '{$1=$1};1'
}

function get_project {
  default=$(get_default_project)
  # $1 = project, if $1 = empty then $default. If $1 != default then default. else $1
  if [ -z "$1" ]; then echo $default;
  elif [ "$1" != "$default" ]; then echo $1;
  else echo $default ; fi;
}

function is_program_inited {
  if [ -f $log_path/config ] ; then exit 0
  else
    logger_debug "The program is not initialized"
    exit 1
  fi
}

function write_to_disk {
  # $1 = project_name
  # $2 = decimal time
  # $3 = military time
  # $4 = Start time
  # $5 = End time
  # $6 = Break minutes
  # $7 = Note [optional]
  project=$1
  dec_time=$2
  mil_time=$3
  start_time=$(echo "$4" | sed 's#\ ##')
  end_time=$(echo "$5" | sed 's#\ ##')
  break_min=$6
  note=$7
  date=$(date +%Y-%m-%d)
  week_date=$(date +%Y-%V-%u)
  proj_log_path=$(get_log_path_for_project $project)
  entry="$week_date/$date [$dec_time]{$mil_time} ($start_time $end_time $break_min) [$note]"
  echo "$entry" >> $proj_log_path
  logger_debug "Writing log entry $entry to $proj_log_path"
}

function get_log_path_for_project {
  echo "$log_path/$1.logs"
}

function time_to_decimal_time {
  # t1 = $1
  # t1h = the hour in 24h-format
  # t1m = the hour in 24h-format

  # t2 = $2
  # t2h = the hour in 24h-format
  # t2m = the hour in 24h-format

  # t3 = $3
  # t1h = the hour in 24h-format
  t1h=$1
  t1m=$2
  t2h=$3
  t2m=$4
  t3m=$5

  if  [ "$t1h" -ge 0 ] ||
      [ "$t1h" -le 23 ] ||
      [ "$t2h" -ge 0 ] ||
      [ "$t2h" -le 23 ]
  then
    # Remove leading zeros
	t1h=${t1h#0}
	t1m=${t1m#0}
	t2h=${t2h#0}
    t2m=${t2m#0}

    # Minimize stuff

    # We want to subtract hours here.
    # 0830 & 1600 => 0000 & 0830
    # 0725 & 1210 => 0000 & 0445

    if [ "$t1m" -gt "$t2m" ]  # 0830, 1600.
    then
        # t2's minute is lesser. Add 60 to it and subtract t2h by one.
        # 0725 & 1210 => 0725 & 1170 => ((11-07) => 04, (70-25) => 45)
        t2h=$((t2h-=1))
        t2m=$((t2m+60))
    fi # t1m -gt t2m

    # Should be good to go, do the subtraction
    t2h=$((t2h-t1h))
    t2m=$((t2m-t1m))

    # t1h, t1m not relevant any more.
    unset t1h ; unset t1m

    # Fix third argument
    if [ ! -z "$t3m" ] && [ "$t3m" -gt 0 ] # is not empty or negative
    then
        # Wrap it up with an if-statement checking if t3m/60 is larger than t2h. If so, break is larger than end time.
        tbh=$((t3m/60))
        total_min=$((t2h*60+(t2m)))

        if [ "$t3m" -lt "$total_min" ] # is it even a valid procedure?
        then
            if [ "$t2m" -gt "$t3m" ] # if there is room to just subtract. (h1=0445; h2=45;h2-h1)=>0400
            then
                t2m=$((t2m-t3m))
            else
                # Since t2m is lower than t3m, borrow hours from t2h and then subtract
                temp=$(echo "$t3m")
                while [ "$t3m" -gt "$t2m" ]
                do
                    t2h=$((t2h-=1))
                    t2m=$((t2m+60))
                done
                t2m=$((t2m-temp))
            fi # t3m -lt total_min
        fi # t3m -lt total_min
    fi # ! -z t3m && t3m -gt 0

    # 10# because it might contain leading 0's
    # total_minutes = ((4*60) => 240, (45) => 45) => 295
    # total_minutes=$((10#$t2h*60 + 10#$t2m))

    dectime=$(awk "BEGIN {print ($t2h+($t2m/60))}")
    # append 0 so 4:9 => 04:09.
    if [ ${#t2h} -eq 1 ]; then t2h="0$t2h"; fi
    if [ ${#t2m} -eq 1 ]; then t2m="0$t2m"; fi
    echo "$dectime/$t2h:$t2m"
    exit 0
  fi
  logger_debug "Could not compute: $t1h $t1m $t2h $t2m $t3m"
  exit 1
}

function calculate_time_with_parameters {
  # start_time = $1(hh mm)
  # stop_time = $2(hh mm)
  # break_minutes = $3(mm)
  # project = $4(string)

  t1h=$(echo "${1:0:2}")
  t1m=$(echo "${1:3:5}")
  t2h=$(echo "${2:0:2}")
  t2m=$(echo "${2:3:5}")
  t3m=$3
  project=$4

  both_times=$(time_to_decimal_time $t1h $t1m $t2h $t2m $t3m)
  dec_time=$(echo $both_times | grep -o '^[0-9]\+\.*[0-9]*')
  mil_time=$(echo $both_times | grep -o '\/[0-9]\+:[0-9]*' | sed 's#\/##')
  echo "Times: $t1h:$t1m, $t2h:$t2m, $t3m. Decimal time: $dec_time Military time: $mil_time"

  echo "Save this to $proj_name project log? y/n"
  read confirm
  logger_debug "Confirm: '$confirm'"
  [ "$confirm" = "y" ] && write_to_disk $project $dec_time $mil_time "$1" "$2" "$3"
}

specify_project="n"

# Get all projects for the program
get_all_projects

# If empty arguments, call usage
if [ $# -eq 0 ]; then usage 0; fi

# main
while [[ $# -ge 1 ]]; do
  logger_debug "Processing '$1'"
  case $1 in
    create)
      case "$2" in
        project)
          logger_debug "About to describe project project"
          new_project="y"
          specify_project="n"
          shift ; shift
        ;;
        *)
          echo "Could not comprehend '$2' with create keyword"
          shift
        ;;
      esac
    ;;
    show)
      case "$2" in
        logs)
          show_logs="y"
          specify_project="y"
          proj_name=$(get_project_from_id $3)
          action="show logs for?"
          if [ ! -z "$proj_name" ]; then
            logger_debug "ID from argument matched: '$3'"
            specify_project="n"
            shift
          fi

          k=$(echo "$3" | grep -o '[0-9]*')
          if [[ "$k" == "$3" && $k -ge 0 && $k -le 52 ]]; then
            logger_debug "Week from argument matched: '$3'"
            show_logs_week=$3
            shift
          fi

          elem=$(echo $3 | grep -o '[0-9]*')
          if [[ ! -z "$3" && $elem == $3 ]]; then
            logger_debug "Year from argument matched: '$3'"
            year=$elem
            shift
          fi

          shift ; shift
        ;;
        *)
          echo "Could not comprehend '$2' with show keyword"
          shift
        ;;
      esac
    ;;
    delete)
      case "$2" in
        project)
          delete_project="y"
          specify_project="n"
          shift ; shift
        ;;
        *)
          echo "Could not comprehend '$2' with delete keyword"
          shift
        ;;
      esac
    ;;
    --help)
      usage 0
    ;;
    --note)
      note=$2
      shift; shift
    ;;
    --dev)
      logger_debug "Setting '$2' to \$log_path"
      log_path=$2
      get_all_projects
      project_ids_only=$(echo "$all_projects" | grep -o '\[.*\]')
      logger_debug "'$2' contains the project ids: '$project_ids_only'"
      shift ; shift
    ;;
    --raw)
      raw_logs="y"
      shift
    ;;
    log)
      logger_debug "Log time matched"
      log_time="y"
      specify_project="y"
      id_matched="n"
      action="log time for"
      proj_name=$(get_project_from_id $2)
      if [ ! -z "$proj_name" ] ; then
        logger_debug "Matched project id from argument: '$2'"
        specify_project="n"
        shift
      else
        logger_debug "'$2' was not a project"
      fi

      maybeStart=$2
      [ ! -z "$2" ] && { logger_debug "Shifting $2"; shift ; }
      maybeEnd=$2
      [ ! -z "$2" ] && { logger_debug "Shifting $2"; shift ; }
      maybeBreak=$2
      [ ! -z "$2" ] && { logger_debug "Shifting $2"; shift ; }
      shift
    ;;
    -v)
      logger_debug "Debug is toggled"
      log_level=1
      shift
    ;;
    list)
      case "$2" in
        projects)
          list_projects="y"
          specify_project="n"
          shift
        ;;
        project_id)
          list_projects | grep -o '\[[^]]*\]' | sed 's#^\[##g; s#\]$##g' | tr '\n' ' '
          shift
        ;;
        *)
          echo "Could not comprehend '$2' with list keyword"
          shift
        ;;
      esac
      shift
    ;;
    edit)
      case "$2" in
        logs)
          specify_project="y"
          edit_logs="y"
          proj_name=$(get_project_from_id "$3")
          action="edit logs for"
          if [ ! -z "$proj_name" ]; then
            specify_project="n"
            id_matched="y"
            shift
          fi
          shift
        ;;
        *)
          echo "Could not comprehend '$2' with edit keyword"
          shift
        ;;
      esac
      shift
    ;;
    --version)
      echo "$(basename 0) $version"
    ;;
    --examples)
      examples
    ;;
    *)
      logger_debug "About to call usage '$1'"
      echo "Unknown argument $1"
      usage 1
      shift
    ;;
  esac
done

# if united, init
if [ -z "$uninstall" ]; then
  k=$(is_program_inited)
  if [ $? -eq 1 ]; then init_program; fi
fi

# If the program requires a project
if [ "$specify_project" != "n" ]; then
  # select max number from left most number in list projects
  proj_amount=$(echo "$all_projects" | grep -o '^[0-9]' | wc -l)
  if [ $proj_amount -ge 1 ]; then
    if [ $proj_amount -eq 1 ]; then
      logger_debug "Only one project created, getting it"
      proj_name=$(get_project_from_id ".*")
      logger_debug "Got '$proj_name'"
    else
      logger_debug "Project input: '$proj_name'"
      old_proj_name=$proj_name
      logger_debug "Is ID matched? '$id_matched'"

      if [ "$id_matched" = "y" ]; then
        proj_name=$(get_project_from_id $proj_name) ;
        logger_debug "Specifying a project with id_name '$proj_name'" ;
      else
        echo "Here are the projects you have created:"
        echo "$all_projects"
        echo "What project are you trying to $action?"
        read prompt_new_proj_name
        proj_name=$prompt_new_proj_name
        proj_name=$(get_project_from_all_projects $prompt_new_proj_name)
      fi
      [ -z "$proj_name" ] && { echo "'$old_proj_name' is not a valid project"; usage 1; }

      logger_debug "Project is set as '$proj_name'"
    fi
  else
    echo "This action requires you to specify a project but there is no created projects. Create a project with 'create project' keywords"
    exit 0
  fi
fi

if [ ! -z $new_project ]; then
  describe_project
fi

if [ ! -z "$list_projects" ]; then
  if [ ! -z "$all_projects" ]; then
    echo "The projects are:"
    echo "$all_projects"
  else
    echo "No projects! Create one with 'create project' keywords"
  fi
  exit 0
fi

if [ ! -z "$delete_project" ]; then
  delete_project
  exit 0
elif [ ! -z "$show_logs" ]; then
  if [ ! -z "$all_projects" ]; then
    if [ -z "$raw_logs" ]; then
      if [ -z "$show_logs_week" ]; then
        echo "For what week? Current week is $(date +%V)"
        read week
        show_logs_week=$week
      fi
      logger_debug "project: $proj_name"

      if [ ! -z "$proj_name" ]; then
        get_project_meta_info $proj_name
        logger_debug "Showing logs for $proj_name given week $show_logs_week"
        if [ -z "$year" ]; then year=$(date +%Y); fi
        week_stats "$(cat $log_path/$proj_name.logs)" "$show_logs_week" "$year"
      fi
    else
      logger_debug "About to start less with $log_path/${proj_name}.logs as argument"
      less "$log_path/${proj_name}.logs"
    fi
  else
    echo "Can't show logs if no projects exists"
  fi
elif [ ! -z "$log_time" ]; then
  logger_debug "About to log time"
  if [ ! -z "$proj_name" ]; then
    if [[ -z "$maybeStart" ]]; then
      echo "What start hour:minute? (e.g. 8, 8:10, 08:25, 0835)"
      read start_timestamp
    else
      start_timestamp=$maybeStart
    fi
    if [[ -z "$maybeEnd" ]]; then
      echo "What end hour:minute? (e.g. 8, 8:10, 08:25, 0835)"
      read end_timestamp
    else
      end_timestamp=$maybeEnd
    fi
    if [[ -z "$maybeBreak" ]]; then
      echo "How large of a break(in minutes)?"
      read break_time
    else
      break_time=$maybeBreak
    fi

    logger_debug "times: $2 $3 $4"

    format="8, 800, 8:00, 0800, 08:00"
    start_time=$(parse_timestamp $start_timestamp)
    k=$(test_timestamp "$start_time")
    [ $? -eq 0 ] || { echo "'$start_time' is not a number! '$start_time' does not follow $format"; echo "$k"; usage 1; }

    stop_time=$(parse_timestamp $end_timestamp)
    k=$(test_timestamp "$end_time")
    [ $? -eq 0 ] || { echo "'$end_time' is not a number! '$end_time' does not follow $format"; echo "$k"; usage 1; }

    break_minutes=$break_time
    k="$(test_break $break_time)"
    [ $? -eq 0 ] || { echo "'$break_time' is not a number!"; usage 1; }

    logger_debug "Inputs: Start:$start_timestamp End:$end_timestamp Break:$break_time"
    logger_debug "Parsed: Start:$start_time End:$stop_time Break:$break_minutes"
    calculate_time_with_parameters "$start_time" "$stop_time" $break_minutes $proj_name
  else
    logger_debug "Could not log time since the project name send to this section was unset."
  fi
elif [ ! -z "$edit_logs" ]; then
  if [ ! -z "$(which xdg-open >/dev/null 2>&1)" ]; then
    logger_debug "Opening with xdg-open"
    xdg-open "$log_path/${proj_name}.logs";
  elif [ ! -z "$EDITOR" ]; then
    logger_debug "Opening with \$EDITOR"
    "${EDITOR}" "$log_path/${proj_name}.logs"
  else
    logger_debug "Opening with vim, default"
    vim "$log_path/${proj_name}.logs"
  fi
fi

exit 0
